name: ami-build-ci

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  test:
    name: ami-build
    runs-on: ubuntu-latest
    if: github.repository == 'CSYE-Cloud-Pragati/webapp'

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      DB_HOST: 127.0.0.1
      DB_NAME: ${{ secrets.DB_NAME }}
      DB_PORT: ${{ secrets.DB_PORT }}
      DB_USER: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      PORT: ${{ secrets.PORT }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}         # DEV credentials
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_KEY }}         # DEV credentials
      AMI_USERS: ${{ secrets.AMI_USERS }}
      AUTHENTICATION_ENABLED: ${{ secrets.AUTHENTICATION_ENABLED }}
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
      GCP_ZONE: ${{ secrets.GCP_ZONE }}

      DEMO_AWS_ACCESS_KEY: ${{ secrets.DEMO_AWS_ACCESS_KEY }}
      DEMO_AWS_SECRET_KEY: ${{ secrets.DEMO_AWS_SECRET_KEY }}
      DEMO_AWS_ACCOUNT_ID: ${{ secrets.DEMO_AWS_ACCOUNT_ID }}

      AWS_REGION: ${{ secrets.AWS_REGION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create Zip File
        run: |
          zip -r webapp.zip .

      - name: Upload Zip File
        uses: actions/upload-artifact@v4
        with:
          name: webapp zip creation
          path: webapp.zip

      - name: Moving Zip to APP_TEST
        run: |
          ls
          pwd
          sudo mv /home/runner/work/webapp/webapp/webapp.zip /home/runner/work/webapp/webapp/src/

      - name: Run Packer
        id: build_ami
        run: |
          # INSTALL PACKER
          curl -fsSL https://releases.hashicorp.com/packer/1.7.3/packer_1.7.3_linux_amd64.zip -o packer.zip
          unzip packer.zip
          sudo mv packer /usr/local/bin/
          ls
          pwd
          cd src
          packer init ubuntu.pkr.hcl
          packer build \
            -var 'db_name=${{ secrets.DB_NAME }}' \
            -var 'db_user=${{ secrets.DB_USERNAME }}' \
            -var 'db_password=${{ secrets.DB_PASSWORD }}' \
            -var 'aws_region=${{ secrets.AWS_REGION }}' \
            -var 'source_ami=${{ secrets.SOURCE_AMI }}' \
            -var 'aws_access_key=${{ secrets.AWS_ACCESS_KEY }}' \
            -var 'aws_secret_key=${{ secrets.AWS_SECRET_KEY }}' \
            -var 'ami_users=${{ secrets.AMI_USERS }}' \
            ubuntu.pkr.hcl
          # EXTRACT THE AMI ID USING AWS CLI (ensure the AMI name matches the filter pattern)
          AMI_ID=$(aws ec2 describe-images \
            --owners self \
            --filters "Name=name,Values=webapp-aws-*" \
            --query "sort_by(Images, &CreationDate)[-1].ImageId" \
            --output text \
            --region "${AWS_REGION}")
          if [ -z "$AMI_ID" ]; then
            echo "ERROR: AMI_ID is empty. Please verify that the AMI was built correctly."
            exit 1
          fi
          echo "AMI_ID: $AMI_ID"
          echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT

      - name: Share AMI with DEMO account
        run: |
          # USE THE OUTPUT FROM THE BUILD AMI STEP
          aws ec2 modify-image-attribute \
            --image-id ${{ steps.build_ami.outputs.ami_id }} \
            --launch-permission "Add=[{UserId=${{ secrets.DEMO_AWS_ACCOUNT_ID }} }]" \
            --region ${{ secrets.AWS_REGION }}

      - name: Reconfigure AWS CLI for DEMO Account
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.DEMO_AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.DEMO_AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify DEMO Account Credentials
        run: |
          aws sts get-caller-identity
          echo "Listing available launch templates..."
          aws ec2 describe-launch-templates --query "LaunchTemplates[*].LaunchTemplateId" --output text --region ${{ secrets.AWS_REGION }}

      - name: DEBUG Describe Launch Templates
        run: |
          aws ec2 describe-launch-templates --region ${{ secrets.AWS_REGION }} \
          --launch-template-ids ${{ secrets.LAUNCH_TEMPLATE_ID }}

      - name: UPDATE LAUNCH TEMPLATE WITH LATEST AMI
        run: |
            AMI_ID=${{ steps.build_ami.outputs.ami_id }}
            echo "Updating launch template with AMI_ID: $AMI_ID"
            # Explicitly include instance type with the AMI ID
            aws ec2 create-launch-template-version \
              --launch-template-id ${{ secrets.LAUNCH_TEMPLATE_ID }} \
              --launch-template-data "{\"ImageId\":\"$AMI_ID\"}" \
              --region ${{ secrets.AWS_REGION }}
    
            # Wait for change to propagate
            sleep 5

      - name: UPDATE AUTO SCALING GROUP WITH LATEST LAUNCH TEMPLATE VERSION
        run: |
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${{ secrets.AUTO_SCALING_GROUP_NAME }} \
            --launch-template LaunchTemplateId=${{ secrets.LAUNCH_TEMPLATE_ID }}

      - name: ISSUE INSTANCE REFRESH ON ASG
        run: |
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${{ secrets.AUTO_SCALING_GROUP_NAME }} \
            --region ${{ secrets.AWS_REGION }}

      - name: WAIT FOR ASG INSTANCE REFRESH TO COMPLETE
        run: |
          echo "WAITING FOR ASG INSTANCE REFRESH TO COMPLETE..."
          REFRESH_STATUS="InProgress"
          TIMEOUT=600
          INTERVAL=30
          ELAPSED=0
          while [ "$REFRESH_STATUS" = "InProgress" ] && [ $ELAPSED -lt $TIMEOUT ]; do
              sleep $INTERVAL
              ELAPSED=$((ELAPSED+INTERVAL))
              REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes --auto-scaling-group-name ${{ secrets.AUTO_SCALING_GROUP_NAME }} --query "InstanceRefreshes[0].Status" --output text --region ${{ secrets.AWS_REGION }})
              echo "STATUS: $REFRESH_STATUS, ELAPSED: $ELAPSED SECONDS"
          done
          if [ "$REFRESH_STATUS" != "Successful" ]; then
              echo "INSTANCE REFRESH FAILED OR TIMED OUT."
              exit 1
          fi
          echo "INSTANCE REFRESH COMPLETED SUCCESSFULLY."
